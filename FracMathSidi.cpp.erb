#include "Config.h"
#include "Norm.h"
#include "Types.h"

#include <algorithm>
#include <functional>
#include <iostream>
#include <utility>
#include <vector>

#include <cassert>
#include <cmath>

static FloatType Epsilon {0.05};

// Erroneus steffenson's method.
static ValType calcNextSteffensonL(std::function<ValType(ValType)> F, ValType Pt) {
  ValType Tmp = F(Pt);
  ValType Tmp2 = F(Tmp);
  return Pt - (Tmp * Tmp) / (Tmp2 - Tmp);
}

static PtColor
getPointIndexGeneralizedSecant(ValType Init) {
  static auto Fn = [](ValType Pt) {
    return <%= expr %>;
  };

  constexpr unsigned Size = 8;
  constexpr unsigned Mask = Size - 1;
  constexpr unsigned Degree = 7;
  constexpr unsigned PNum = Degree + 1;

  // TODO: add bootstrap
  ValType Pts[Size] = {Init};
  for (unsigned i = 1; i < PNum; ++i)
    Pts[i] = calcNextSteffensonL(Fn, Pts[i - 1]);

  // Differences window.
  ValType DW[PNum][Size];
  for (unsigned i = 0; i < PNum; ++i)
    DW[0][i] = Fn(Pts[i]);

  for (unsigned i = 1; i < PNum; ++i)
    for (unsigned j = i; j < PNum; ++j) {
      DW[i][j] = (DW[i - 1][j] - DW[i - 1][j - 1]) / (Pts[j] - Pts[j - i]);
    }

  unsigned Cur = Degree;
  ValType Diffs[Degree];
  for (unsigned i = 0; i < Degree; ++i)
    Diffs[i] = Pts[Cur] - Pts[i];

  for (int i = 0; i < MaxIters; ++i) {
    ValType Last = DW[Degree][Cur];
    ValType Drv = Last;
    for (unsigned j = Degree - 1; j > 0; --j) {
      Drv *= Diffs[j - 1];
      Last = DW[j][(Cur - Degree + j) & Mask] + Last * Pts[j];
      Drv += Last;
    }

    unsigned Tmp = Cur;
    Cur = (Cur + 1) & Mask;
    Pts[Cur] = Pts[Tmp] + DW[0][Tmp] / Drv;

    if (std::isnan(Pts[Cur].real()) || std::isnan(Pts[Cur].imag()))
      break;

    if (normInf(Fn(Pts[Cur])) < Epsilon)
      return {true, std::arg(Pts[Cur])};

    
    // Renew table.
    DW[0][Cur] = Fn(Pts[Cur]);
    for (unsigned j = 1; j < PNum; ++j) {
      DW[j][(Cur + j) & Mask] =
        (DW[j - 1][(Cur + j) & Mask] - DW[j - 1][(Cur + j - 1) & Mask]) /
        (Pts[Cur] - Pts[(Cur - j) & Mask]);
    }
  }

  return {false, 0.0};
}

void getFractal(std::vector<PtColor> &ColorIdxs) {
  assert(ColorIdxs.size() == (XLen * YLen) && "Colors size is wrong!");
  ValType Point;
  for (int i = MinX; i < MaxX; ++i) {
    double X = static_cast<double>(i) / Scale + CX;
    for (int j = MinY; j < MaxY; ++j) {
      double Y = static_cast<double>(j) / Scale + CY;
      auto Val = getPointIndexGeneralizedSecant(ValType(X, Y));
      int Idx = (i - MinX) * XLen + (j - MinY);
      assert(Idx >= 0 && "Idx is less that 0");      
      ColorIdxs[Idx] = Val;
    }
    std::cerr << '.';
  }
  std::cerr << '\n';
}
